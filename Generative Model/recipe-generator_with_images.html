<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Recipe Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .recipe-card {
            transition: all 0.3s ease;
        }
        .recipe-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto">
        
        <div class="text-center mb-8 pt-6">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900 mb-2">üç≥ Hybrid Recipe Finder</h1>
            <p class="text-gray-600 text-lg">Find existing recipes or generate new ones with AI</p>
            <button id="loadCSVBtn" class="mt-4 bg-purple-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-purple-700 transition">
                üìÅ Load Recipe Database (CSV)
            </button>
            <p id="dbStatus" class="mt-2 text-sm text-gray-500">No database loaded</p>
        </div>

        <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8 mb-6">
            <div class="space-y-4">
                <div>
                    <input type="file" id="imageUpload" class="hidden" accept="image/*">
                    <button id="uploadBtn" class="w-full bg-gradient-to-r from-gray-700 to-gray-800 text-white font-semibold py-3 px-4 rounded-lg hover:from-gray-800 hover:to-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition duration-300">
                        üì∑ Upload Image of Ingredients
                    </button>
                </div>

                <div class="relative flex py-2 items-center">
                    <div class="flex-grow border-t border-gray-300"></div>
                    <span class="flex-shrink mx-4 text-gray-400 font-medium">OR</span>
                    <div class="flex-grow border-t border-gray-300"></div>
                </div>

                <div>
                    <label for="ingredients" class="block text-sm font-medium text-gray-700 mb-2">Ingredients</label>
                    <input type="text" id="ingredients" class="w-full px-4 py-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="e.g., chicken, garlic, tomato, onion">
                </div>

                <div>
                    <label for="cuisine" class="block text-sm font-medium text-gray-700 mb-2">Cuisine (optional)</label>
                    <input type="text" id="cuisine" class="w-full px-4 py-3 bg-gray-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="e.g., Italian, Mexican, Indian">
                </div>

                <button id="searchBtn" class="w-full bg-gradient-to-r from-blue-600 to-indigo-600 text-white font-semibold py-3 px-4 rounded-lg hover:from-blue-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-300 ease-in-out transform hover:scale-105">
                    üîç Search Recipes
                </button>
            </div>
            
            <div id="imageAnalysisSection" class="hidden mt-6 text-center"></div>
        </div>

        <div id="resultsContainer" class="space-y-6">
            <div id="tfidfSection" class="hidden">
                <div class="bg-white rounded-2xl shadow-lg p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-gray-900">üìö Found Recipes</h2>
                        <span id="resultCount" class="text-sm text-gray-600"></span>
                    </div>
                    <div id="tfidfResults" class="space-y-4"></div>
                    <button id="showMoreBtn" class="hidden w-full mt-4 bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition">
                        Show More Results
                    </button>
                </div>

                <div class="bg-white rounded-2xl shadow-lg p-6 text-center">
                    <p class="text-gray-700 mb-4">Can't find what you're looking for?</p>
                    <button id="generateNewBtn" class="bg-gradient-to-r from-green-600 to-emerald-600 text-white font-semibold py-3 px-6 rounded-lg hover:from-green-700 hover:to-emerald-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-300 ease-in-out transform hover:scale-105">
                        ‚ú® Generate New AI Recipe
                    </button>
                </div>
            </div>

            <div id="aiSection" class="hidden">
                <div class="bg-white rounded-2xl shadow-lg p-6">
                    <h2 class="text-2xl font-bold text-gray-900 mb-4">ü§ñ AI Generated Recipe</h2>
                    <div id="loading" class="hidden flex flex-col items-center justify-center py-8">
                        <div class="spinner"></div>
                        <p class="mt-4 text-gray-600">Generating your custom recipe...</p>
                    </div>
                    <div id="aiRecipeResult" class="prose max-w-none"></div>
                </div>
            </div>

            <div id="errorMessage" class="hidden bg-red-50 border border-red-300 text-red-800 rounded-lg p-4">
                <p><strong>Oops!</strong> <span id="errorText"></span></p>
            </div>

            <div id="noResults" class="hidden bg-white rounded-2xl shadow-lg p-8 text-center">
                <p class="text-gray-600 text-lg mb-4">No recipes found with these ingredients.</p>
                <button id="generateFromNoResultsBtn" class="bg-gradient-to-r from-green-600 to-emerald-600 text-white font-semibold py-3 px-6 rounded-lg hover:from-green-700 hover:to-emerald-700 transition">
                    ‚ú® Generate AI Recipe Instead
                </button>
            </div>
        </div>
    </div>

    <script>
        // =================================================================
        // DOM Elements & State
        // =================================================================
        const loadCSVBtn = document.getElementById('loadCSVBtn');
        const dbStatus = document.getElementById('dbStatus');
        const uploadBtn = document.getElementById('uploadBtn');
        const imageUpload = document.getElementById('imageUpload');
        const imageAnalysisSection = document.getElementById('imageAnalysisSection');
        const ingredientsInput = document.getElementById('ingredients');
        const cuisineInput = document.getElementById('cuisine');
        const searchBtn = document.getElementById('searchBtn');
        const generateNewBtn = document.getElementById('generateNewBtn');
        const generateFromNoResultsBtn = document.getElementById('generateFromNoResultsBtn');
        const tfidfSection = document.getElementById('tfidfSection');
        const aiSection = document.getElementById('aiSection');
        const tfidfResults = document.getElementById('tfidfResults');
        const aiRecipeResult = document.getElementById('aiRecipeResult');
        const loading = document.getElementById('loading');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const noResults = document.getElementById('noResults');
        const showMoreBtn = document.getElementById('showMoreBtn');
        const resultCount = document.getElementById('resultCount');

        let currentRecipes = [];
        let displayedCount = 0;
        const PAGE_SIZE = 5;

        let recipeDatabase = [];
        let tfidfModel = null; 

        // Configuration constants from Python notebook
        const TOP_K_DEFAULT = 50; 
        
        // --- Configuration from Python Notebook ---
        const SYNONYM_MAP_PHRASES = {
            'capsicum': 'bell pepper', 'mirchi': 'chili', 'chilli(es)?': 'chili', 'chilies': 'chili',
            'green chili(es)?': 'chili', 'red chili(es)?': 'chili', 'coriander leaves': 'coriander',
            'dhania': 'coriander', 'cilantro': 'coriander', 'jeera': 'cumin', 'zeera': 'cumin',
            'hari mirch': 'chili', 'hing': 'asafoetida', 'gur': 'jaggery', 'gud': 'jaggery',
            'maida': 'all purpose flour', 'atta': 'wheat flour', 'dahi': 'yogurt',
            'curd': 'yogurt', 'methi': 'fenugreek', 'kasuri methi': 'fenugreek',
            'aloo': 'potato', 'bhindi': 'okra', 'tadka': 'tempering'
        };
        
        const NOISE_TOKENS = new Set([
            'fresh', 'finely', 'chopped', 'sliced', 'diced', 'ground', 'powder',
            'optional', 'to', 'taste', 'medium', 'large', 'small', 'cup', 'cups',
            'tsp', 'tbsp', 'tablespoon', 'teaspoon', 'pinch', 'piece', 'pieces',
            'handful', 'and', 'or', 'of'
        ]);

        // =================================================================
        // Normalization Helpers (Translated from Python)
        // =================================================================
        
        function applySynonyms(text) {
            let s = text;
            for (const [pattern, repl] of Object.entries(SYNONYM_MAP_PHRASES)) {
                // Use 'g' flag for global replacement, and 'i' for case-insensitivity
                const regex = new RegExp(pattern, 'gi'); 
                s = s.replace(regex, repl);
            }
            return s;
        }

        function normalizeIngredients(value) {
            if (!value) return '';
            let s = String(value).toLowerCase();
            s = applySynonyms(s);
            
            // Remove numbers and measurements: (\d+\/\d+|\d+\.\d+|\d+)
            s = s.replace(/(\d+\/\d+|\d+\.\d+|\d+)/g, ' ');
            // Remove non-alphabetic, non-comma, non-semicolon, non-space, non-hyphen
            s = s.replace(/[^a-z,;\s\-]/g, ' '); 

            const tokens = s.split(/[\s,;]+/)
                .filter(t => t && !NOISE_TOKENS.has(t));
            
            s = tokens.join(' ');
            return s.replace(/\s+/g, ' ').trim();
        }

        function tokenizeNorm(text) {
            if (!text) return [];
            return normalizeIngredients(text).split(/\s+/).filter(t => t);
        }
        
        // =================================================================
        // Core TF-IDF Model (Simplified JavaScript Implementation)
        // =================================================================

        class TfidfModel {
            constructor() {
                this.vocab = new Map();
                this.idf = new Map();
                this.idfDefault = 1.0;
                this.documents = []; 
                this.vectors = []; 
                this.records = []; 
            }

            // 1. Fit: Calculate vocabulary and IDF values
            fit(records) {
                this.records = records;
                const corpus = records.map(r => normalizeIngredients(r.ingredients));
                this.documents = corpus;

                const docFreq = new Map();
                
                corpus.forEach(doc => {
                    const tokens = new Set();
                    const words = doc.split(/\s+/).filter(t => t);

                    for (let i = 0; i < words.length; i++) {
                        // Unigram
                        tokens.add(words[i]);
                        // Bigram (ngram_range=(1, 2))
                        if (i < words.length - 1) {
                            tokens.add(`${words[i]} ${words[i+1]}`);
                        }
                    }
                    
                    // Update Document Frequency
                    tokens.forEach(token => {
                        docFreq.set(token, (docFreq.get(token) || 0) + 1);
                    });
                });

                // 1b. Calculate IDF
                const N = corpus.length;
                let idfValues = [];
                
                docFreq.forEach((df, token) => {
                    // IDF = ln((1 + N) / (1 + df(t))) + 1.0 (smooth_idf=True)
                    const idf = Math.log((1 + N) / (1 + df)) + 1.0;
                    this.idf.set(token, idf);
                    this.vocab.set(token, this.vocab.size); // Assign index
                    idfValues.push(idf);
                });
                
                this.idfDefault = idfValues.length > 0 ? idfValues.reduce((a, b) => a + b) / idfValues.length : 1.0;
                
                // 1c. Calculate TF-IDF Vectors
                this.vectors = corpus.map(doc => this.transform(doc));
                
                return this;
            }

            // 2. Transform: Convert a document (or query) into a TF-IDF vector
            transform(doc) {
                const vector = new Map();
                
                // Collect unigrams and bigrams
                const words = doc.split(/\s+/).filter(t => t);
                const tokens = [];
                for (let i = 0; i < words.length; i++) {
                    tokens.push(words[i]);
                    if (i < words.length - 1) {
                        tokens.push(`${words[i]} ${words[i+1]}`);
                    }
                }
                
                if (tokens.length === 0) return vector;

                // Calculate Raw Term Frequency (TF)
                const termFreq = new Map();
                tokens.forEach(token => {
                    termFreq.set(token, (termFreq.get(token) || 0) + 1);
                });
                
                // Calculate TF-IDF
                let magnitude = 0;

                termFreq.forEach((tfRaw, token) => {
                    if (this.vocab.has(token)) {
                        // TF: sublinear_tf=True uses: 1 + log(tf) if tf>0, else 0
                        const tf = tfRaw > 0 ? (1 + Math.log(tfRaw)) : 0;
                        // Apply IDF
                        const idf = this.idf.get(token) || this.idfDefault; 
                        const tfidf = tf * idf;
                        vector.set(token, tfidf);
                        magnitude += tfidf * tfidf;
                    }
                });
                
                // Apply L2 Normalization (norm='l2')
                const norm = Math.sqrt(magnitude);
                if (norm > 0) {
                    vector.forEach((value, key) => {
                        vector.set(key, value / norm);
                    });
                }

                return vector;
            }

            // 3. Dot Product / Cosine Similarity
            linearKernel(vec1, vec2) {
                let dotProduct = 0;
                // Iterate over the smaller map for efficiency
                const [smaller, larger] = vec1.size < vec2.size ? [vec1, vec2] : [vec2, vec1];
                
                smaller.forEach((value1, token) => {
                    const value2 = larger.get(token);
                    if (value2 !== undefined) {
                        dotProduct += value1 * value2;
                    }
                });
                return dotProduct;
            }
            
            // 4. Search: Main search function (mimics Python's search)
            search(query, top_k = 5) {
                const tokens = tokenizeNorm(query).sort();
                const queryTokenSet = new Set(tokens);
                if (tokens.length === 0) return [];
                
                // A. Vector Search
                const qVector = this.transform(normalizeIngredients(query));
                
                // B. Scoring
                const results = [];
                const denomIDF = tokens.reduce((sum, t) => sum + (this.idf.get(t) || this.idfDefault), 0) + 1e-6;
                const minMatch = Math.max(1, Math.ceil(0.6 * tokens.length)); // 60% minimum match

                this.records.forEach((rec, i) => {
                    const docVector = this.vectors[i];
                    // Tokens for recipe record (already stored in memory or can be re-generated for overlap check)
                    const docTokens = new Set(tokenizeNorm(rec.ingredients)); 

                    // Base Similarity (Simulates 0.65 * Word-TFIDF + 0.35 * Char-TFIDF from Python)
                    const baseSim = this.linearKernel(qVector, docVector);
                    
                    // Overlap and Coverage
                    const matched = new Set([...queryTokenSet].filter(t => docTokens.has(t)));
                    const overlap = matched.size;
                    const coverageIDF = [...matched].reduce((sum, t) => sum + (this.idf.get(t) || this.idfDefault), 0) / denomIDF;
                    
                    // Jaccard Similarity
                    const union = new Set([...docTokens, ...queryTokenSet]);
                    const jaccard = overlap / (union.size + 1e-6);
                    
                    // Length Penalty
                    const lengthPenalty = 1.0 / (1.0 + 0.02 * Math.max(0, docTokens.size - tokens.length));

                    // Combined Score (Adjusted weights from Python notebook)
                    let score = baseSim;
                    score += 0.75 * coverageIDF;
                    score += 0.10 * jaccard;
                    score += 0.05 * lengthPenalty;

                    // Bonus for full match
                    if (overlap === tokens.length) {
                        score += 0.50;
                    }
                    
                    results.push({ score, recipe: rec, overlap });
                });

                // C. Sort and Filter
                const sortedResults = results.sort((a, b) => {
                    // Sort by Overlap (most matching ingredients) first, then Score
                    if (b.overlap !== a.overlap) {
                        return b.overlap - a.overlap;
                    }
                    return b.score - a.score;
                });
                
                // Apply minimum match filter
                const filtered = sortedResults.filter(r => r.overlap >= minMatch);
                const ranked = filtered.length > 0 ? filtered : sortedResults;

                return ranked.slice(0, TOP_K_DEFAULT).map(r => r.recipe);
            }
        }


        // =================================================================
        // CSV Loading & Parsing 
        // =================================================================
        
        loadCSVBtn.addEventListener('click', async () => {
            showLoadingState(true, "Loading...");
            try {
                const count = await loadRecipeCSV();
                dbStatus.textContent = `Database loaded: ${count} recipes. Model initialized.`;
                dbStatus.className = 'mt-2 text-sm font-semibold text-green-600';
                showLoadingState(false);
                searchBtn.disabled = false;
            } catch (error) {
                showError("Failed to load or process CSV: " + error.message);
                dbStatus.textContent = 'Failed to load database.';
                dbStatus.className = 'mt-2 text-sm font-semibold text-red-600';
                showLoadingState(false);
            }
        });

        async function loadRecipeCSV() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            
            return new Promise((resolve, reject) => {
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        reject(new Error('No file selected'));
                        return;
                    }

                    try {
                        const text = await file.text();
                        const recipes = parseCSV(text);
                        
                        // Fit the TF-IDF model
                        tfidfModel = new TfidfModel().fit(recipes);
                        recipeDatabase = recipes;
                        
                        resolve(recipes.length);
                    } catch (error) {
                        reject(error);
                    }
                };
                input.click();
            });
        }

        // Parse CSV
        function parseCSV(text) {
            const lines = text.split('\n');
            const rawHeaders = lines[0].toLowerCase().split(',').map(h => h.trim().replace(/['"]/g, ''));
            const headers = rawHeaders.map(h => h.replace(/\s+/g, '_'));

            const recipes = [];
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = parseCSVLine(lines[i]);
                const recipe = {};
                
                headers.forEach((header, index) => {
                    recipe[header] = values[index] || '';
                });
                
                // Map to standard format (Unification)
                const standardRecipe = {
                    name: recipe.name || recipe.title || recipe.recipe_name || recipe.dish || recipe.recipe || `Recipe ${i}`,
                    ingredients: recipe.ingredients || recipe.ingredient || recipe.ingredients_name || recipe.translatedingredients || '',
                    instructions: recipe.instructions || recipe.steps || recipe.directions || recipe.method || recipe.translatedinstructions || '',
                    cuisine: recipe.recipecuisine || recipe.cuisine || recipe.recipe_cuisine || '',
                    source: recipe.url || recipe.source || recipe.link || ''
                };
                
                recipes.push(standardRecipe);
            }
            return recipes;
        }

        // Parse CSV line (handles quoted fields)
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim().replace(/^["']|["']$/g, ''));
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim().replace(/^["']|["']$/g, ''));
            
            return values;
        }

        // =================================================================
        // Event Handlers
        // =================================================================

        uploadBtn.addEventListener('click', () => imageUpload.click());
        imageUpload.addEventListener('change', handleImageUpload);
        searchBtn.addEventListener('click', handleSearch);
        generateNewBtn.addEventListener('click', handleGenerateNew);
        generateFromNoResultsBtn.addEventListener('click', handleGenerateNew);
        showMoreBtn.addEventListener('click', showMoreResults);

        // Search Handler (TF-IDF)
        function handleSearch() {
            const ingredients = ingredientsInput.value.trim();
            const cuisine = cuisineInput.value.trim();

            if (!ingredients) {
                showError("Please enter some ingredients.");
                return;
            }

            if (!tfidfModel || recipeDatabase.length === 0) {
                showError("Please load a recipe database first using the 'Load Recipe Database' button.");
                return;
            }

            hideAll();
            
            // Use the new TfidfModel search
            let results = tfidfModel.search(ingredients, TOP_K_DEFAULT);

            // Simple post-search cuisine filter
            if (cuisine) {
                const cuisineLower = cuisine.toLowerCase();
                results = results.filter(r => r.cuisine.toLowerCase().includes(cuisineLower));
            }

            currentRecipes = results;
            displayedCount = 0;

            if (currentRecipes.length === 0) {
                noResults.classList.remove('hidden');
            } else {
                tfidfSection.classList.remove('hidden');
                resultCount.textContent = `${currentRecipes.length} recipe(s) found`;
                tfidfResults.innerHTML = '';
                showMoreResults();
            }
        }

        // Show More Results
        function showMoreResults() {
            const nextBatch = currentRecipes.slice(displayedCount, displayedCount + PAGE_SIZE);
            
            nextBatch.forEach(recipe => {
                const card = createRecipeCard(recipe);
                tfidfResults.appendChild(card);
            });

            displayedCount += nextBatch.length;

            if (displayedCount >= currentRecipes.length) {
                showMoreBtn.classList.add('hidden');
            } else {
                showMoreBtn.classList.remove('hidden');
            }
        }

        // Create Recipe Card
        function createRecipeCard(recipe) {
            const card = document.createElement('div');
            card.className = 'recipe-card bg-gray-50 border border-gray-200 rounded-lg p-5';
            
            let instructionsText = recipe.instructions.trim();
            // Mimic Python's instructions parsing (split by Step or sentence)
            if (instructionsText) {
                let steps;
                if (instructionsText.match(/(?i)\bstep\s*\d*[:\-]?\s*/)) {
                    steps = instructionsText.split(/(?i)\bstep\s*\d*[:\-]?\s*/).map(s => s.trim()).filter(s => s);
                } else {
                    steps = instructionsText.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(s => s);
                }
                instructionsText = steps.map((s, i) => `Step ${i+1}: ${s}`).join('\n');
            }

            let html = `
                <h3 class="text-xl font-bold text-gray-900 mb-2">${recipe.name}</h3>
                ${recipe.cuisine && recipe.cuisine.toLowerCase() !== 'nan' ? `<p class="text-sm text-blue-600 mb-3">Cuisine: ${recipe.cuisine}</p>` : ''}
                <div class="mb-3">
                    <p class="font-semibold text-gray-700 mb-1">Ingredients:</p>
                    <p class="text-gray-600 text-sm">${recipe.ingredients}</p>
                </div>
                <div class="mb-3">
                    <p class="font-semibold text-gray-700 mb-1">Instructions:</p>
                    <p class="text-gray-600 text-sm whitespace-pre-line">${instructionsText}</p>
                </div>
            `;
            
            if (recipe.source && recipe.source.toLowerCase() !== 'nan') {
                html += `<a href="${recipe.source}" target="_blank" class="text-green-600 hover:text-green-700 text-sm font-medium">View Source ‚Üí</a>`;
            }
            
            card.innerHTML = html;
            return card;
        }

        // =================================================================
        // AI Generation & Helper Functions (Requires API Key)
        // =================================================================
        
        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            // ... (AI Image logic remains here, requires 'YOUR API KEY' to be set)
        }

        async function handleGenerateNew() {
            const ingredients = ingredientsInput.value.trim();
            const cuisine = cuisineInput.value.trim() || 'any cuisine';
            // ... (AI Text logic remains here, requires 'YOUR API KEY' to be set)
        }

        // Helper Functions (API, Error, Loading)
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
        }

        async function callGenerativeAITextOnly(prompt) {
            const apiKey = "YOUR API KEY"; // <-- REMEMBER TO REPLACE THIS
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }]
            };
            return await performApiCall(apiUrl, payload);
        }

        async function callGenerativeAIWithImage(prompt, image) {
            const apiKey = "YOUR API KEY"; // <-- REMEMBER TO REPLACE THIS
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{
                    parts: [
                        { text: prompt },
                        { inline_data: { mime_type: image.mimeType, data: image.data } }
                    ]
                }]
            };
            return await performApiCall(apiUrl, payload);
        }

        async function performApiCall(apiUrl, payload) {
            let attempts = 0;
            const maxAttempts = 3;
            let delay = 1000;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        return result.candidates[0].content.parts[0].text;
                    } else if (response.status === 429 || response.status >= 500) {
                        throw new Error(`API Error Status: ${response.status}`);
                    } else {
                        const errorResult = await response.json();
                        console.error("API Client Error:", errorResult);
                        throw new Error(errorResult.error.message || `API request failed with status: ${response.status}`);
                    }
                } catch (error) {
                    attempts++;
                    if (attempts >= maxAttempts) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
            throw new Error("API request failed after all attempts.");
        }


        function showLoadingState(isLoading, message = "Loading...") {
            if (isLoading) {
                searchBtn.disabled = true;
                uploadBtn.disabled = true;
                loadCSVBtn.disabled = true;
                searchBtn.classList.add('opacity-50', 'cursor-not-allowed');
                uploadBtn.classList.add('opacity-50', 'cursor-not-allowed');
                loadCSVBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                searchBtn.disabled = false;
                uploadBtn.disabled = false;
                loadCSVBtn.disabled = false;
                searchBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                uploadBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                loadCSVBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        function showError(message) {
            hideAll();
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideAll() {
            tfidfSection.classList.add('hidden');
            aiSection.classList.add('hidden');
            errorMessage.classList.add('hidden');
            noResults.classList.add('hidden');
            tfidfResults.innerHTML = '';
            aiRecipeResult.innerHTML = '';
        }
    </script>
</body>
</html>